<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>iPhone Color Picker</title>

<style>
body {
    background-color: #121212;
    color: #ffffff;
    font-family: -apple-system, BlinkMacSystemFont, "San Francisco", sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
    overflow: hidden;
}

.picker-container {
    position: relative;
    width: 400px;
    height: 400px;
    border-radius: 50%;
    background-color: #000;
    overflow: hidden;
    touch-action: none;
}

#imageCanvas {
    position: absolute;
    width: 100%;
    height: 100%;
}

.crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 30px;
    height: 30px;
    background-color: rgba(255,255,255,0.4);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
}

#fileInput { display: none; }
</style>
</head>

<body>

<div class="picker-container" id="pickerContainer">
    <canvas id="imageCanvas" width="600" height="600"></canvas>
    <div class="crosshair"></div>
</div>

<input type="file" id="fileInput" accept="image/*">

<script>
const container = document.getElementById('pickerContainer');
const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const fileInput = document.getElementById('fileInput');

let img = new Image();
let imgLoaded = false;
let state = { scale: 1, pointX: 0, pointY: 0 };
const canvasSize = 600;

/* 拖动更跟手 */
const DRAG_SPEED = 3.5;

/* ===== 连续点击（用 touchend） ===== */
let tapCount = 0;
let tapTimer = null;
const TAP_INTERVAL = 500;
let touchMoved = false;

container.addEventListener('touchstart', () => {
    touchMoved = false;
});

container.addEventListener('touchmove', () => {
    touchMoved = true;
});

container.addEventListener('touchend', (e) => {
    if (touchMoved) return;

    tapCount++;

    if (tapCount === 1) {
        tapTimer = setTimeout(() => {
            tapCount = 0;
        }, TAP_INTERVAL);
    }

    if (tapCount === 3) {
        clearTimeout(tapTimer);
        tapCount = 0;
        fileInput.value = '';
        fileInput.click();
    }
});

/* ===== 拖动 / 缩放 ===== */
let initialPinchDistance = null;
let lastScale = 1;
let isDragging = false;
let lastX = 0;
let lastY = 0;
let velocityX = 0;
let velocityY = 0;
let rafId = null;

container.addEventListener('touchstart', (e) => {
    if (!imgLoaded) return;
    e.preventDefault();

    if (e.touches.length === 1) {
        isDragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        isDragging = false;
        initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
        lastScale = state.scale;
    }
}, { passive: false });

container.addEventListener('touchmove', (e) => {
    if (!imgLoaded) return;
    e.preventDefault();

    if (e.touches.length === 1 && isDragging) {
        velocityX += (e.touches[0].clientX - lastX) * DRAG_SPEED;
        velocityY += (e.touches[0].clientY - lastY) * DRAG_SPEED;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;

        if (!rafId) rafId = requestAnimationFrame(applyDrag);
    } 
    else if (e.touches.length === 2 && initialPinchDistance) {
        const d = getDistance(e.touches[0], e.touches[1]);
        state.scale = Math.max(0.1, Math.min(10, lastScale * d / initialPinchDistance));
        drawImage();
    }
}, { passive: false });

container.addEventListener('touchend', () => {
    isDragging = false;
    initialPinchDistance = null;
});

function applyDrag() {
    state.pointX += velocityX;
    state.pointY += velocityY;
    velocityX *= 0.6;
    velocityY *= 0.6;

    drawImage();

    if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1) {
        rafId = requestAnimationFrame(applyDrag);
    } else {
        rafId = null;
        velocityX = velocityY = 0;
    }
}

/* ===== 图片 ===== */
fileInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = ev => {
        img.onload = () => {
            imgLoaded = true;
            state.scale = 1;
            state.pointX = canvasSize / 2;
            state.pointY = canvasSize / 2;
            drawImage();
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
});

function getDistance(a, b) {
    return Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
}

function drawImage() {
    ctx.clearRect(0, 0, canvasSize, canvasSize);
    ctx.save();
    ctx.translate(canvasSize / 2, canvasSize / 2);
    ctx.scale(state.scale, state.scale);
    ctx.translate(state.pointX - canvasSize / 2, state.pointY - canvasSize / 2);
    ctx.drawImage(img, -img.width / 2, -img.height / 2);
    ctx.restore();
}
</script>

</body>
</html>