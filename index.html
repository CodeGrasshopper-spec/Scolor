<script>
const container = document.getElementById('pickerContainer');
const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const fileInput = document.getElementById('fileInput');
const rgbLabel = document.getElementById('rgbVal');
const labLabel = document.getElementById('labVal');
const placeholder = document.getElementById('placeholder');

let img = new Image();
let imgLoaded = false;
let state = { scale: 1, pointX: 0, pointY: 0 };
const canvasSize = 600;

/* 只提高倍率，不做惯性 */
const DRAG_SPEED = 3.0;

/* ===== 稳定三击 ===== */
let tapCount = 0;
let tapTimer = null;
let touchMoved = false;
const TAP_INTERVAL = 500;

container.addEventListener('touchstart', () => {
    touchMoved = false;
});

container.addEventListener('touchmove', () => {
    touchMoved = true;
});

container.addEventListener('touchend', () => {
    if (touchMoved) return;

    tapCount++;
    if (tapCount === 1) {
        tapTimer = setTimeout(() => tapCount = 0, TAP_INTERVAL);
    }

    if (tapCount === 3) {
        clearTimeout(tapTimer);
        tapCount = 0;
        fileInput.value = '';
        fileInput.click();
    }
});

/* ===== 拖动 & 缩放 ===== */
let isDragging = false;
let lastX = 0;
let lastY = 0;
let initialPinchDistance = null;
let lastScale = 1;

container.addEventListener('touchstart', (e) => {
    if (!imgLoaded) return;
    e.preventDefault();

    if (e.touches.length === 1) {
        isDragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        isDragging = false;
        initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
        lastScale = state.scale;
    }
}, { passive: false });

container.addEventListener('touchmove', (e) => {
    if (!imgLoaded) return;
    e.preventDefault();

    if (e.touches.length === 1 && isDragging) {
        const dx = e.touches[0].clientX - lastX;
        const dy = e.touches[0].clientY - lastY;

        state.pointX += dx * DRAG_SPEED;
        state.pointY += dy * DRAG_SPEED;

        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;

        drawImage();
    } 
    else if (e.touches.length === 2 && initialPinchDistance) {
        const d = getDistance(e.touches[0], e.touches[1]);
        state.scale = Math.max(0.1, Math.min(10, lastScale * d / initialPinchDistance));
        drawImage();
    }
}, { passive: false });

container.addEventListener('touchend', () => {
    isDragging = false;
    initialPinchDistance = null;
});

/* ===== 图片 ===== */
fileInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = ev => {
        img.onload = () => {
            imgLoaded = true;
            placeholder.style.display = 'none';
            state.scale = 1;
            state.pointX = canvasSize / 2;
            state.pointY = canvasSize / 2;
            drawImage();
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
});

/* ===== 绘制 & 取色 ===== */
function drawImage() {
    ctx.clearRect(0, 0, canvasSize, canvasSize);
    ctx.save();
    ctx.translate(canvasSize / 2, canvasSize / 2);
    ctx.scale(state.scale, state.scale);
    ctx.translate(state.pointX - canvasSize / 2, state.pointY - canvasSize / 2);
    ctx.drawImage(img, -img.width / 2, -img.height / 2);
    ctx.restore();
    analyzeColor();
}

function analyzeColor() {
    const p = ctx.getImageData(canvasSize / 2, canvasSize / 2, 1, 1).data;
    updateUI(p[0], p[1], p[2]);
}

function updateUI(r, g, b) {
    rgbLabel.innerText = `RGB: ${r}, ${g}, ${b}`;
    const lab = rgb2lab([r, g, b]);
    labLabel.innerText = `L:${lab[0].toFixed(1)} a:${lab[1].toFixed(1)} b:${lab[2].toFixed(1)}`;
}

function rgb2lab(rgb) {
    let [r, g, b] = rgb.map(v => {
        v /= 255;
        return v > 0.04045 ? Math.pow((v + 0.055) / 1.055, 2.4) : v / 12.92;
    });
    let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;
    let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;
    let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;
    x /= 95.047; y /= 100; z /= 108.883;
    [x, y, z] = [x, y, z].map(v => v > 0.008856 ? Math.cbrt(v) : (7.787 * v + 16 / 116));
    return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
}

function getDistance(a, b) {
    return Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
}
</script>