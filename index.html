<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>S Color Picker</title>

<style>
body {
    background-color: #000;
    color: #ffffff;
    font-family: -apple-system, BlinkMacSystemFont, "San Francisco", sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
    overflow: hidden;
}

/* 外包正方形 */
.picker-wrapper {
    position: relative;
    width: 420px;
    height: 420px;
}

/* 黑色圆形 */
.picker-container {
    position: absolute;
    left: 20px;
    top: 40px;
    width: 380px;
    height: 380px;
    border-radius: 50%;
    background-color: #000;
    overflow: hidden;
    touch-action: none;
}

#imageCanvas {
    position: absolute;
    width: 100%;
    height: 100%;
}

/* 中心准星 */
.crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 30px;
    height: 30px;
    background-color: rgba(255,255,255,0.4);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
}

/* 正上方灰色大圆按钮 */
.import-btn {
    position: absolute;
    top: 0;
    left: 50%;
    width: 34px;
    height: 34px;
    background: #888;
    border-radius: 50%;
    transform: translateX(-50%);
    z-index: 20;
}

#fileInput { display: none; }

.info-panel {
    margin-top: 30px;
    text-align: center;
    width: 95%; /* 稍微加宽一点以容纳更多数值 */
    max-width: 450px;
}

.color-values {
    font-family: "SF Mono", monospace;
    font-size: 13px; /* 稍微缩小字体以免折行 */
    color: #aaa;
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

.placeholder-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #555;
    pointer-events: none;
}
</style>
</head>

<body>

<div class="picker-wrapper">
    <div class="import-btn" id="importBtn"></div>

    <div class="picker-container" id="pickerContainer">
        <canvas id="imageCanvas" width="600" height="600"></canvas>
        <div class="crosshair"></div>
        <div id="placeholder" class="placeholder-text">0.0</div>
    </div>
</div>

<input type="file" id="fileInput" accept="image/*">

<div class="info-panel">
    <div class="color-values">
        <span id="rgbVal">RGB: 0, 0, 0</span>
        <span id="hslVal">HSL: 0, 0%, 0%</span>
        <span id="labVal">Lab: 0.0, 0.0, 0.0</span>
    </div>
</div>

<script>
const container = document.getElementById('pickerContainer');
const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const fileInput = document.getElementById('fileInput');
const importBtn = document.getElementById('importBtn');
const placeholder = document.getElementById('placeholder');
const rgbLabel = document.getElementById('rgbVal');
const hslLabel = document.getElementById('hslVal'); // 新增
const labLabel = document.getElementById('labVal');

let img = new Image();
let imgLoaded = false;
let state = { scale: 1, pointX: 0, pointY: 0 };
const canvasSize = 600;

const DRAG_SPEED = 2.0;

importBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    fileInput.value = '';
    fileInput.click();
});

let isDragging = false;
let lastTouchX = 0;
let lastTouchY = 0;
let initialPinchDistance = null;
let lastScale = 1;

container.addEventListener('touchstart', (e) => {
    if (!imgLoaded) return;
    e.preventDefault();
    if (e.touches.length === 1) {
        isDragging = true;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        isDragging = false;
        initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
        lastScale = state.scale;
    }
}, { passive: false });

container.addEventListener('touchmove', (e) => {
    if (!imgLoaded) return;
    e.preventDefault();
    if (e.touches.length === 1 && isDragging) {
        const dx = e.touches[0].clientX - lastTouchX;
        const dy = e.touches[0].clientY - lastTouchY;
        state.pointX += dx * DRAG_SPEED;
        state.pointY += dy * DRAG_SPEED;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
        drawImage();
    } 
    else if (e.touches.length === 2 && initialPinchDistance) {
        const d = getDistance(e.touches[0], e.touches[1]);
        state.scale = Math.max(0.1, Math.min(10, lastScale * d / initialPinchDistance));
        drawImage();
    }
}, { passive: false });

container.addEventListener('touchend', () => {
    isDragging = false;
    initialPinchDistance = null;
});

fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        img.onload = () => {
            imgLoaded = true;
            placeholder.style.display = 'none';
            state.scale = 1;
            state.pointX = canvasSize / 2;
            state.pointY = canvasSize / 2;
            drawImage();
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
});

function drawImage() {
    ctx.clearRect(0, 0, canvasSize, canvasSize);
    ctx.save();
    ctx.translate(canvasSize / 2, canvasSize / 2);
    ctx.scale(state.scale, state.scale);
    ctx.translate(state.pointX - canvasSize / 2, state.pointY - canvasSize / 2);
    ctx.drawImage(img, -img.width / 2, -img.height / 2);
    ctx.restore();
    analyzeColor();
}

function analyzeColor() {
    const p = ctx.getImageData(canvasSize / 2, canvasSize / 2, 1, 1).data;
    updateUI(p[0], p[1], p[2]);
}

function updateUI(r, g, b) {
    // 更新 RGB
    rgbLabel.innerText = `RGB: ${r}, ${g}, ${b}`;
    
    // 更新 HSL (新增)
    const hsl = rgb2hsl(r, g, b);
    hslLabel.innerText = `HSL: ${hsl[0]}, ${hsl[1]}%, ${hsl[2]}%`;
    
    // 更新 Lab
    const lab = rgb2lab([r, g, b]);
    labLabel.innerText = `L:${lab[0].toFixed(1)} a:${lab[1].toFixed(1)} b:${lab[2].toFixed(1)}`;
}

/**
 * RGB 转 HSL 转换函数 (新增)
 */
function rgb2hsl(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // 灰色
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [
        Math.round(h * 360),
        Math.round(s * 100),
        Math.round(l * 100)
    ];
}

function rgb2lab(rgb) {
    let [r, g, b] = rgb.map(v => {
        v /= 255;
        return v > 0.04045 ? Math.pow((v + 0.055) / 1.055, 2.4) : v / 12.92;
    });
    let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;
    let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;
    let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;
    x /= 95.047; y /= 100; z /= 108.883;
    [x, y, z] = [x, y, z].map(v => v > 0.008856 ? Math.cbrt(v) : (7.787 * v + 16 / 116));
    return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
}

function getDistance(a, b) {
    return Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
}
</script>

</body>
</html>
