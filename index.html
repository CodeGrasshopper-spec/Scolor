<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>iPhone Color Picker</title>

<style>
body {
    background-color: #121212;
    color: #ffffff;
    font-family: -apple-system, BlinkMacSystemFont, "San Francisco", sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
    overflow: hidden;
}

/* 外包正方形（稍微大一点，给按钮留空间） */
.picker-wrapper {
    position: relative;
    width: 420px;
    height: 420px;
}

/* 黑色圆形（缩小） */
.picker-container {
    position: absolute;
    left: 20px;
    top: 40px;
    width: 380px;
    height: 380px;
    border-radius: 50%;
    background-color: #000;
    overflow: hidden;
    touch-action: none;
}

#imageCanvas {
    position: absolute;
    width: 100%;
    height: 100%;
}

/* 中心准星 */
.crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 30px;
    height: 30px;
    background-color: rgba(255,255,255,0.4);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
}

/* 正上方灰色大圆按钮 */
.import-btn {
    position: absolute;
    top: 0;
    left: 50%;
    width: 34px;
    height: 34px;
    background: #888;
    border-radius: 50%;
    transform: translateX(-50%);
    z-index: 20;
}

#fileInput { display: none; }

.info-panel {
    margin-top: 30px;
    text-align: center;
    width: 90%;
    max-width: 400px;
}

.color-values {
    font-family: "SF Mono", monospace;
    font-size: 14px;
    color: #aaa;
    display: flex;
    justify-content: space-around;
}

.placeholder-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #555;
    pointer-events: none;
}
</style>
</head>

<body>

<div class="picker-wrapper">
    <div class="import-btn" id="importBtn"></div>

    <div class="picker-container" id="pickerContainer">
        <canvas id="imageCanvas" width="600" height="600"></canvas>
        <div class="crosshair"></div>
        <div id="placeholder" class="placeholder-text">0.0</div>
    </div>
</div>

<input type="file" id="fileInput" accept="image/*">

<div class="info-panel">
    <div class="color-values">
        <span id="rgbVal">RGB: 0, 0, 0</span>
        <span id="labVal">Lab: 0.0, 0.0, 0.0</span>
    </div>
</div>

<script>
const container = document.getElementById('pickerContainer');
const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const fileInput = document.getElementById('fileInput');
const importBtn = document.getElementById('importBtn');
const placeholder = document.getElementById('placeholder');
const rgbLabel = document.getElementById('rgbVal');
const labLabel = document.getElementById('labVal');

let img = new Image();
let imgLoaded = false;
let state = { scale: 1, pointX: 0, pointY: 0 };
const canvasSize = 600;

/* 拖动速度 ×2 */
const DRAG_SPEED = 6.0;

/* 导入图片 */
importBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    fileInput.value = '';
    fileInput.click();
});

/* 拖动 / 缩放 */
let isDragging = false;
let lastTouchX = 0;
let lastTouchY = 0;
let initialPinchDistance = null;
let lastScale = 1;

container.addEventListener('touchstart', (e) => {
    if (!imgLoaded) return;
    e.preventDefault();

    if (e.touches.length === 1) {
        isDragging = true;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        isDragging = false;
        initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
        lastScale = state.scale;
    }
}, { passive: false });

container.addEventListener('touchmove', (e) => {
    if (!imgLoaded) return;
    e.preventDefault();

    if (e.touches.length === 1 && isDragging) {
        const dx = e.touches[0].clientX - lastTouchX;
        const dy = e.touches[0].clientY - lastTouchY;

        state.pointX += dx * DRAG_SPEED;
        state.pointY += dy * DRAG_SPEED;

        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;

        drawImage();
    } 
    else if (e.touches.length === 2 && initialPinchDistance) {
        const d = getDistance(e.touches[0], e.touches[1]);
        state.scale = Math.max(0.1, Math.min(10, lastScale * d / initialPinchDistance));
        drawImage();
    }
}, { passive: false });

container.addEventListener('touchend', () => {
    isDragging = false;
    initialPinchDistance = null;
});

/* 文件 */
fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = ev => {
        img.onload = () => {
            imgLoaded = true;
            placeholder.style.display = 'none';
            state.scale = 1;
            state.pointX = canvasSize / 2;
            state.pointY = canvasSize / 2;
            drawImage();
        };
        img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
});

/* 绘制 / 取色 */
function drawImage() {
    ctx.clearRect(0, 0, canvasSize, canvasSize);
    ctx.save();
    ctx.translate(canvasSize / 2, canvasSize / 2);
    ctx.scale(state.scale, state.scale);
    ctx.translate(state.pointX - canvasSize / 2, state.pointY - canvasSize / 2);
    ctx.drawImage(img, -img.width / 2, -img.height / 2);
    ctx.restore();
    analyzeColor();
}

function analyzeColor() {
    const p = ctx.getImageData(canvasSize / 2, canvasSize / 2, 1, 1).data;
    updateUI(p[0], p[1], p[2]);
}

function updateUI(r, g, b) {
    rgbLabel.innerText = `RGB: ${r}, ${g}, ${b}`;
    const lab = rgb2lab([r, g, b]);
    labLabel.innerText = `L:${lab[0].toFixed(1)} a:${lab[1].toFixed(1)} b:${lab[2].toFixed(1)}`;
}

function rgb2lab(rgb) {
    let [r, g, b] = rgb.map(v => {
        v /= 255;
        return v > 0.04045 ? Math.pow((v + 0.055) / 1.055, 2.4) : v / 12.92;
    });
    let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) * 100;
    let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) * 100;
    let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) * 100;
    x /= 95.047; y /= 100; z /= 108.883;
    [x, y, z] = [x, y, z].map(v => v > 0.008856 ? Math.cbrt(v) : (7.787 * v + 16 / 116));
    return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
}

function getDistance(a, b) {
    return Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
}
</script>

</body>
</html>